// just a file to dump some lox code into were testing while interpreter is build

fun doSomething() {
    var x = 0;
    while (x<10) {
        x = x + 1;
    }
    print x;
}
//doSomething();

fun outer() {
  var x = "outside";
  fun inner() {
    print x;
  }
  inner();
}
//outer(); // should print outside



// testing stack trance:
fun a() { b(); }
fun b() { c(); }
fun c() {
  c("too", "many"); // this only 'breaks' at runtime
}
// a();         // will produce a full stacktrace with the error in c()








// some test code for classes:
class Brioche {

}

print Brioche;    // the class -> prints "Brioche"
print Brioche();  // a instance of the class Brioche -> prints "Brioche instance"

class Pair {}

var pair = Pair();
pair.first = 1;
pair.second = 2;
print pair.first + pair.second; // prints 3.


// closures bug hunting:
// when closures are implemented this should print out outer:

var x = "global";
fun outer() {
  var x = "outer";
  fun inner() {
    print x;
  }
  inner();
}
outer();    // closure captured "outer" and should print that

// closures here can capture the same outer variable inc.
fun incrementClosure() {
  var inc = 50;
  fun inner() {
    inc = inc +10;
    print inc;
  }
  return inner;
}
var a = incrementClosure();
var b = incrementClosure();
//a();
//a();  // this captures the same inc as the above
//b();  // this captures another inc
//b();  // same inc as above
//b();  // same inc as above


class Scone {
  topping(first, second) {
    print "scone with " + first + " and " + second;
  }
}

var scone = Scone();
scone.topping("berries", "cream");  // prints out: scone with beries and cream


class Person {
  sayName() {
    print this.name;
  }
}

var jane = Person();
jane.name = "Jane";

var method = jane.sayName;
method(); // prints out: Jane


class CoffeeMaker {
  init(coffee) {
    this.coffee = coffee;
  }

  brew() {
    print "Enjoy your cup of " + this.coffee;

    // No reusing the grounds!
    this.coffee = nil;
  }
}

var maker = CoffeeMaker("coffee and chicory");
maker.brew();


// fields can hold functions of their own and get called correctly:
class Oops {
  init() {
    fun f() {
      print "not a method";
    }

    this.field = f;
  }
}

var oops = Oops();
oops.field();